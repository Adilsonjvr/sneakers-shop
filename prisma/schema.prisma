// -------------------------------------------
// Prisma Schema — High-Cost Sneakers (Air Jordans)
// Banco: PostgreSQL
// -------------------------------------------

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// -------------------------------------------
// ENUMS
// -------------------------------------------

enum Currency {
  EUR
  USD
  GBP
}

enum ProductStatus {
  DRAFT
  ACTIVE
  INACTIVE
}

enum AvailabilityState {
  /// Disponibilidade agregada exibida ao cliente (heatmap na PDP)
  IN_STOCK
  LOW_STOCK
  OUT_OF_STOCK
}

enum ModelLine {
  /// Linhas principais (expandir conforme necessário)
  AJ1
  AJ3
  AJ4
  AJ11
  OTHER
}

enum AddressType {
  SHIPPING
  BILLING
  BOTH
}

enum OrderStatus {
  PENDING_PAYMENT
  PAID
  FULFILLED
  PARTIALLY_REFUNDED
  REFUNDED
  CANCELLED
}

enum PaymentProvider {
  STRIPE
}

enum PaymentStatus {
  REQUIRES_ACTION
  REQUIRES_PAYMENT_METHOD
  PROCESSING
  AUTHORIZED
  CAPTURED
  SUCCEEDED
  CANCELED
  REQUIRES_CONFIRMATION
  FAILED
}

enum RefundStatus {
  REQUESTED
  PENDING
  SUCCEEDED
  FAILED
  CANCELED
}

enum RefundReason {
  CUSTOMER_REQUEST
  DEFECT
  LOGISTICS
  FRAUD_SUSPECTED
  OTHER
}

enum DiscountType {
  PERCENT
  FIXED
}

enum Role {
  ADMIN
  MANAGER
  SUPPORT
}

enum ActorType {
  ADMIN
  CUSTOMER
  SYSTEM
}

enum QueueTicketStatus {
  QUEUED
  RELEASED   // liberado para compra
  REJECTED   // bloqueado por regra anti-bot
  EXPIRED
}

enum ReservationStatus {
  ACTIVE
  CONVERTED  // virou pedido pago
  EXPIRED
  CANCELLED
}

// -------------------------------------------
// MODELOS DE IDENTIDADE
// -------------------------------------------

model AdminUser {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  email        String   @unique
  name         String?
  passwordHash String
  role         Role     @default(ADMIN)

  auditLogs    AuditLog[] @relation("AdminActorLogs")
}

/// Cliente final (consumidor). Pode ter vários endereços,
/// pedidos, reservas de stock, tickets de fila e wishlists/coleções.
model Customer {
  id                 String    @id @default(cuid())
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  email              String    @unique
  name               String?
  phone              String?
  /// NIF/VAT (Portugal/EU) — opcional
  vatNumber          String?
  marketingOptIn     Boolean   @default(false)

  addresses          Address[]
  orders             Order[]
  reservations       InventoryReservation[]
  queueTickets       DropQueueTicket[]
  wishlists          Wishlist[]
  collections        Collection[]

  @@index([createdAt])
}

/// Endereços do cliente. Marcação de padrão para faturação/expedição.
model Address {
  id                 String      @id @default(cuid())
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  customer           Customer?   @relation(fields: [customerId], references: [id], onDelete: SetNull)
  customerId         String?

  type               AddressType @default(BOTH)
  isDefaultShipping  Boolean     @default(false)
  isDefaultBilling   Boolean     @default(false)

  line1              String
  line2              String?
  city               String
  region             String?
  postalCode         String
  country            String

  @@index([customerId])
}

// -------------------------------------------
// CATÁLOGO (Produtos / Variantes / Inventário)
// -------------------------------------------

/// Produto representa a "colorway" + narrativa.
/// Tamanhos ficam em Variant.
model Product {
  id            String          @id @default(cuid())
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  name          String
  brand         String          @default("Jordan")
  modelLine     ModelLine       @default(OTHER)
  /// Colorway exibida na PDP
  colorway      String
  description   String?
  /// Bloco de storytelling (HTML sanitizado no app)
  storyHtml     String?
  materials     String?
  status        ProductStatus   @default(ACTIVE)

  /// Flags e ligações a "drop" via tabela Drop
  isDrop        Boolean         @default(false)

  variants      Variant[]
  drops         Drop[]

  @@index([modelLine, status])
}

/// Variante = uma combinação de tamanho para o Product.
/// Cada Variant possui SKU e 1–1 Inventory.
model Variant {
  id                String            @id @default(cuid())
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt

  product           Product           @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String

  /// SKU único por variante (ex.: AJ1-CHICAGO-42-EU)
  sku               String            @unique
  /// GTIN/EAN opcional (para integrações)
  gtin              String?

  /// Tamanhos (usar precisão 1 casa decimal)
  sizeEu            Decimal?          @db.Decimal(4, 1)
  sizeUs            Decimal?          @db.Decimal(4, 1)
  sizeCm            Decimal?          @db.Decimal(4, 1)

  /// Preço da variante (com IVA incluído para exibição, se for o caso)
  price             Decimal           @db.Decimal(10, 2)
  currency          Currency          @default(EUR)

  /// Estado agregado de disponibilidade (para heatmap)
  availabilityState AvailabilityState @default(IN_STOCK)

  inventory         Inventory?
  orderItems        OrderItem[]
  wishlistItems     WishlistItem[]
  collectionItems   CollectionItem[]
  reservations      InventoryReservation[]

  @@index([productId])
  @@index([availabilityState])
  @@unique([productId, sizeEu, sizeUs, sizeCm])
}

/// Inventário 1–1 com Variant.
/// qtyReserved é derivada de reservas ativas (TTL) + carrinhos em checkout.
model Inventory {
  id            String    @id @default(cuid())
  updatedAt     DateTime  @updatedAt

  variant       Variant   @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId     String    @unique

  qtyOnHand     Int       @default(0)
  qtyReserved   Int       @default(0)
  minThreshold  Int       @default(0)
  location      String?

  @@index([qtyOnHand])
}

// -------------------------------------------
// DROPS, FILA E RESERVAS DE STOCK
// -------------------------------------------

/// "Drop" para um Product (colorway) — controla fila, limites e janela de venda.
model Drop {
  id                String     @id @default(cuid())
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  product           Product    @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId         String

  startAt           DateTime
  endAt             DateTime?

  queueEnabled      Boolean    @default(true)
  perCustomerLimit  Int        @default(1)
  captchaRequired   Boolean    @default(true)
  /// Minutos de reserva no checkout (ex.: 10 min)
  reserveMinutes    Int        @default(10)

  queueTickets      DropQueueTicket[]

  @@index([productId, startAt])
}

/// Ticket de fila por cliente durante o Drop.
/// Único por (drop, customer) para evitar múltiplas filas.
model DropQueueTicket {
  id            String            @id @default(cuid())
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  drop          Drop              @relation(fields: [dropId], references: [id], onDelete: Cascade)
  dropId        String

  customer      Customer?         @relation(fields: [customerId], references: [id], onDelete: SetNull)
  customerId    String?

  status             QueueTicketStatus @default(QUEUED)
  position           Int?
  releasedAt         DateTime?
  expiresAt          DateTime?
  ipHash             String?
  userAgentHash      String?
  clientFingerprint  String?
  riskScore          Float?           @default(0)
  riskReason         String?

  @@unique([dropId, customerId])
  @@index([status, releasedAt])
  @@index([clientFingerprint])
  @@index([ipHash])
}

/// Reserva de stock por variante com TTL (ex.: durante checkout).
/// Evita oversell em alta concorrência. App deve fazer limpeza de expirados.
model InventoryReservation {
  id            String             @id @default(cuid())
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt

  variant       Variant            @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId     String

  customer      Customer?          @relation(fields: [customerId], references: [id], onDelete: SetNull)
  customerId    String?

  quantity      Int                @default(1)
  status        ReservationStatus  @default(ACTIVE)
  expiresAt     DateTime

  /// Identificador de sessão/checkout para idempotência
  checkoutKey   String?

  @@index([variantId, status, expiresAt])
  @@index([customerId])
}

// -------------------------------------------
// PEDIDOS, PAGAMENTOS, CUPONS
// -------------------------------------------

/// Pedido com snapshots de endereço (JSON) para garantir imutabilidade fiscal.
model Order {
  id                 String       @id @default(cuid())
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  customer           Customer?    @relation(fields: [customerId], references: [id], onDelete: SetNull)
  customerId         String?

  status             OrderStatus  @default(PENDING_PAYMENT)
  currency           Currency     @default(EUR)

  /// Totais (boas práticas: subtotal + discount -/ + tax + shipping = total)
  subtotalAmount     Decimal      @db.Decimal(12, 2)
  discountAmount     Decimal      @db.Decimal(12, 2) @default(0)
  taxAmount          Decimal      @db.Decimal(12, 2) @default(0)
  shippingAmount     Decimal      @db.Decimal(12, 2) @default(0)
  totalAmount        Decimal      @db.Decimal(12, 2)

  /// IVA aplicável (ex.: 0.23 para 23%) — armazenado no item também
  vatRate            Decimal?     @db.Decimal(4, 3)

  /// Endereços no momento da compra (snapshot)
  billingAddressJson  Json
  shippingAddressJson Json

  shippingProvider   String?
  trackingCode       String?

  items              OrderItem[]
  payment            Payment?
  coupons            OrderCoupon[]

  @@index([createdAt])
  @@index([status])
}

/// Item do pedido com totais por linha e taxa de imposto aplicada.
model OrderItem {
  id             String   @id @default(cuid())

  order          Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId        String

  variant        Variant  @relation(fields: [variantId], references: [id], onDelete: Restrict)
  variantId      String

  quantity       Int      @default(1)

  unitPrice      Decimal  @db.Decimal(10, 2)
  taxRate        Decimal  @db.Decimal(4, 3) // ex.: 0.230 = 23%
  lineSubtotal   Decimal  @db.Decimal(12, 2)
  lineDiscount   Decimal  @db.Decimal(12, 2) @default(0)
  lineTax        Decimal  @db.Decimal(12, 2) @default(0)
  lineTotal      Decimal  @db.Decimal(12, 2)

  @@index([orderId])
}

/// Pagamento 1–1 com o pedido. Integração Stripe (Payment Intents + Radar).
model Payment {
  id                   String          @id @default(cuid())
  createdAt            DateTime        @default(now())
  updatedAt            DateTime        @updatedAt

  order                Order           @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId              String          @unique

  provider             PaymentProvider @default(STRIPE)
  status               PaymentStatus

  /// Valor efetivamente capturado/confirmado no PSP
  amount               Decimal         @db.Decimal(12, 2)
  currency             Currency        @default(EUR)

  /// Stripe: PaymentIntent e Charge (quando aplicável)
  paymentIntentId      String?         @unique
  chargeId             String?         @unique

  /// Indicadores de risco do Radar (quando disponíveis)
  riskScore            Float?
  riskLevel            String?         // textual (e.g., "elevated", "highest")

  authorizedAt         DateTime?
  capturedAt           DateTime?

  rawResponse          Json?

  refunds              Refund[]

  @@index([status])
  @@index([paymentIntentId])
}

/// Reembolso vinculado a um Payment. Pode ser parcial.
model Refund {
  id            String        @id @default(cuid())
  createdAt     DateTime      @default(now())

  payment       Payment       @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  paymentId     String

  amount        Decimal       @db.Decimal(12, 2)
  status        RefundStatus  @default(PENDING)
  reason        RefundReason  @default(OTHER)

  rawResponse   Json?

  @@index([paymentId])
}

/// Cupom de desconto com limitações globais e por cliente.
model Coupon {
  id                String        @id @default(cuid())
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  code              String        @unique
  description       String?
  discountType      DiscountType
  /// Valor do desconto:
  /// - PERCENT: 0–100 (armazenar como 0–100)
  /// - FIXED: valor monetário na currency definida
  value             Decimal       @db.Decimal(10, 2)

  currency          Currency?     // usar quando FIXED
  maxDiscountValue  Decimal?      @db.Decimal(10, 2) // teto para PERCENT, opcional

  validFrom         DateTime?
  validTo           DateTime?
  active            Boolean       @default(true)

  maxRedemptions    Int?
  perCustomerLimit  Int?          // limite por cliente

  orders            OrderCoupon[]

  @@index([active, validFrom, validTo])
}

/// Ligação N–N (pedido x cupom) com controle de unicidade.
model OrderCoupon {
  id        String  @id @default(cuid())

  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String

  coupon    Coupon  @relation(fields: [couponId], references: [id], onDelete: Restrict)
  couponId  String

  /// Valor efetivamente aplicado deste cupom nesse pedido
  appliedValue Decimal @db.Decimal(10, 2)

  @@unique([orderId, couponId])
  @@index([couponId])
}

// -------------------------------------------
// WISHLIST E COLEÇÕES (CURADORIAS/FILTROS SALVOS)
// -------------------------------------------

/// Lista nomeada do cliente (ex.: "Default", "AJ1 preferidos").
model Wishlist {
  id          String        @id @default(cuid())
  createdAt   DateTime      @default(now())

  customer    Customer      @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId  String

  name        String        @default("Default")
  items       WishlistItem[]

  @@unique([customerId, name])
}

/// Item de wishlist aponta para Variant (tamanho específico).
model WishlistItem {
  id          String    @id @default(cuid())
  createdAt   DateTime  @default(now())

  wishlist    Wishlist  @relation(fields: [wishlistId], references: [id], onDelete: Cascade)
  wishlistId  String

  variant     Variant   @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId   String

  @@unique([wishlistId, variantId])
  @@index([variantId])
}

/// Coleções do cliente: podem representar curadorias ou filtros salvos.
/// `filtersJson` armazena critérios (modelo, materiais, anos, etc.).
model Collection {
  id           String          @id @default(cuid())
  createdAt    DateTime        @default(now())

  customer     Customer        @relation(fields: [customerId], references: [id], onDelete: Cascade)
  customerId   String

  name         String
  filtersJson  Json?

  items        CollectionItem[]

  @@unique([customerId, name])
}

model CollectionItem {
  id            String     @id @default(cuid())

  collection    Collection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  collectionId  String

  variant       Variant    @relation(fields: [variantId], references: [id], onDelete: Cascade)
  variantId     String

  sortOrder     Int?

  @@unique([collectionId, variantId])
  @@index([variantId])
}

// -------------------------------------------
// AUDITORIA E LOGS
// -------------------------------------------

/// Log de auditoria para ações administrativas e eventos de sistema.
model AuditLog {
  id           String     @id @default(cuid())
  timestamp    DateTime   @default(now())

  actorType    ActorType  @default(SYSTEM)
  /// Referência opcional ao Admin que realizou a ação
  adminActor   AdminUser? @relation("AdminActorLogs", fields: [adminActorId], references: [id], onDelete: SetNull)
  adminActorId String?

  /// Metadados do ator cliente (quando aplicável)
  customerId   String?
  ip           String?

  action       String
  entityType   String
  entityId     String?

  metadata     Json?
  message      String?
}
